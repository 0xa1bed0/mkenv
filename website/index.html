<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>mkenv | Disposable Dev Environments for Paranoid Devs</title>
<link rel="stylesheet" href="./styles.css?v=2">
<link rel="icon" type="image/svg+xml" href="./favicon.svg?v=4">
</head>
<body>
<header>
    <div class="logo"><a href="index.html"><img src="./logo.svg" alt="mkenv logo" class="logo-icon">mkenv.sh</a></div>
    <nav>
        <a href="#overview">Overview</a>
        <a href="#problem">The Problem</a>
        <a href="#what">What is mkenv?</a>
        <a href="#configuration">Configuration</a>
        <a href="#installation">Install</a>
        <a href="docs.html">Docs</a>
        <a href="https://github.com/0xa1bed0/mkenv" target="_blank">GitHub</a>
    </nav>
</header>
<div class="experimental-warning">
    ⚠️ <strong>Early Stage Software:</strong> mkenv is experimental. Expect breaking changes, incomplete features, and occasional instability. We're releasing early to gather feedback from developers.
</div>
<div class="container">
    <section class="hero" id="overview">
        <h1>Sandboxed dev environments that feel like localhost</h1>
        <p>mkenv creates disposable Docker containers for your project. No port mapping — ports bind dynamically. No <code>host.docker.internal</code> — localhost just works. No Dockerfile to write — mkenv auto-detects your stack. Sensitive paths like ~/.ssh and ~/.aws are blocked from mounting.</p>
        <pre><code>cd ~/projects/myapp && mkenv .</code></pre>
        <p>Your npm install, pip install, LLM agents, and builds run isolated. Your credentials stay on your host.</p>
        <div class="cta-group">
            <a class="cta-primary" href="https://github.com/0xa1bed0/mkenv" target="_blank">View on GitHub</a>
            <a class="cta-secondary" href="#installation">Get Started</a>
            <a class="cta-secondary" href="docs.html">Read the Docs</a>
        </div>
    </section>

    <section id="problem">
        <h2>THE PROBLEM</h2>
        <div class="problem-block">
            <p>Every time we talk security and isolation we mean tradeoffs:</p>
            <ul>
              <li><strong>Ports need advance planning</strong> — Docker requires you to declare ports upfront. Spin up a server on :8080 mid-session? Restart the whole container.</li>
              <li><strong>localhost doesn't work</strong> — Everything becomes <code>host.docker.internal</code>. Your scripts break. Your configs break. Your muscle memory breaks.</li>
              <li><strong>New languages to learn</strong> — Dockerfile, docker-compose.yml, devcontainer.json. Each with its own syntax, quirks, and gotchas. More files to maintain.</li>
              <li><strong>Docker security is its own field</strong> — Privileged mode, capabilities, seccomp profiles, user namespaces. Get it wrong and your "isolation" is theater.</li>
              <li><strong>Setup complexity</strong> — Hours of configuration before you write a line of code. Then maintain it as your project evolves.</li>
              <li><strong>Tooling overhead</strong> — Your debugger needs remote config. Your terminal multiplexer needs setup. Everything needs one more step.</li>
              <li>Many more (you name it)</li>
            </ul>

            <p>Every developer understands they need isolation. But every day, when it's time to actually set it up, your brain screams "not today." So you run <code>npm install</code> on your host machine. Again.</p>

            <p>We postpone security until something breaks. That's human nature.</p>

            <p>Risk isn't hypothetical:</p>
            <ul>
                <li><strong>XZ Utils Backdoor</strong> — Core Linux library backdoored to tamper with SSH</li>
                <li><strong>Shai-Hulud npm worm</strong> — Self-spreading malware that backdoored hundreds of packages</li>
                <li><strong>PyTorch dependency confusion</strong> — Fake package exfiltrated SSH keys</li>
            </ul>
            <p><a href="attacks.html" target="_blank">See 14 more documented attacks →</a></p>
        </div>
    </section>

    <section id="what">
        <h2>WHAT IS MKENV?</h2>
        <p>Security always comes with a cost — configuration, changed workflows, things that break. mkenv aims to pay that cost for you. It's a CLI that generates hardened Docker environments from your project, handling security configuration, port forwarding, and path blocking so you don't have to.</p>

        <p><strong>mkenv gives you:</strong></p>
        <ul>
            <li><strong>Auto-detection:</strong> Scans your project, detects runtimes (Node, Go, etc.), builds environment automatically. No configuration required.</li>
            <li><strong>Isolated execution:</strong> Your LLM agents and <code>npm install</code> run inside the sandbox, not on your host.</li>
            <li><strong>Localhost behavior:</strong> No port configuration, no <code>host.docker.internal</code>. Just use <code>localhost</code> as always.</li>
            <li><strong>Blocked sensitive paths:</strong> Can't mount ~/.ssh, ~/.aws, ~/.docker, browser profiles, password managers, and many more - even accidentally.</li>
            <li><strong>Pre-flight secret scan:</strong> Before starting, mkenv scans your project for .env files, API keys, private keys, and prompts you to confirm.</li>
            <li><strong>Network audit:</strong> All traffic logged locally. System-critical ports blocked by default.</li>
            <li><strong>Policy engine:</strong> Protects developers from accidental wrong moves. Teams can enforce their own rules — restrict tools, block ports, limit mount paths.</li>
        </ul>

        <h3>Ports just work</h3>
        <p>Run <code>npm run dev</code> inside the sandbox, access it at localhost:3000 in your browser. Run Postgres on your host, access it at localhost:5432 from inside. Bidirectional, on-demand, no configuration. <a href="docs.html#port-forwarding">How it works →</a></p>

        <h3>What makes mkenv environment hardened</h3>
        <ul>
            <li>Runs as non-root user — no sudo in sandbox</li>
            <li>Shell history never stores tokens, keys, secrets</li>
            <li>Critical paths physically blocked from mounting (even if you try)</li>
            <li>Container destroyed on exit — compromised system can't persist</li>
            <li>Only trusted base images used</li>
            <li>Dangerous actions require explicit approval (installing packages, mounting paths, accessing secrets)</li>
        </ul>
        <p>Your workstation runs only Docker, a browser, and the mkenv binary. All dev tools, runtimes, and dependencies stay inside the container.</p>
    </section>

    <section id="comparison">
        <h2>HOW IS THIS DIFFERENT?</h2>
        <p><strong>vs Devcontainers:</strong> No Dockerfile or devcontainer.json to write. Ports bind dynamically without configuration. Security guardrails are built-in — you can't accidentally mount ~/.ssh even if you try.</p>
        <p><strong>vs plain Docker:</strong> With Docker you build and maintain your environment from scratch, learning security quirks along the way. mkenv auto-detects your project, handles port forwarding bidirectionally, and bakes in security defaults. No Dockerfile to write or maintain.</p>
        <p><strong>vs Nix/Devbox:</strong> Those manage your toolchain but run code on your host. mkenv runs everything in a container — actual isolation, not just reproducibility.</p>
        <p><strong>vs all of them:</strong> mkenv has a policy engine. Developers are protected from accidental mistakes (mounting credentials, exposing dangerous ports). Teams can enforce their own rules. None of the alternatives have this built-in.</p>
        <p><strong>Audit trail:</strong> mkenv logs everything — network connections, port bindings, package installs, system changes. Full audit trail stored locally. When something goes wrong, you know exactly what happened.</p>
    </section>

    <section id="configuration">
        <h2>ADVANCED CONFIGURATION (OPTIONAL)</h2>
        <p>Most projects need zero configuration — mkenv auto-detects your stack. When you do need to customize, we keep it minimal. No new DSL to learn, no 500-line YAML files.</p>

        <h3>.mkenv Configuration Files</h3>
        <p>Customize project defaults without repeating command-line flags. Place <code>.mkenv</code> files in your project root or parent directories for multi-project settings.</p>
        <p>Bricks are atomic building blocks that mkenv uses to generate your environment — things like <code>claude-code</code>, <code>nvim</code>, <code>node</code>, <code>go</code>.</p>
        <pre><code>{
  "enabled_bricks": ["claude", "nvim"],
  "volumes": ["~/data:/data"]
}</code></pre>
        <p><a href="docs.html#mkenv-files">Full .mkenv documentation →</a></p>

        <h3>Policy Configuration</h3>
        <p>Enforce security policies using <code>policy.json</code>. Control which tools can be used, restrict mount paths, and manage port access.</p>
        <pre><code>{
  "disabled_bricks": ["codex"],
  "allowed_project_path": "/home/user/projects",
  "reverse_proxy": {
    "denied_ports": [5432, 3306]
  }
}</code></pre>
        <p>Policy files use read-only permissions (<code>chmod 444</code>) to prevent unauthorized modification.</p>
        <p><a href="docs.html#policies">Full policy documentation →</a></p>

        <h3>More Documentation</h3>
        <p>See the <a href="docs.html">full documentation</a> for commands, bricks, troubleshooting, and advanced features.</p>
    </section>

    <section id="installation">
        <h2>INSTALLATION</h2>
        <div class="note">
            <strong>Platform Support:</strong> Currently macOS only. Linux support in development. Windows support planned via WSL.
        </div>
        <p><strong>Prerequisites:</strong> Docker Desktop or Docker Engine must be installed and running</p>
        <h3>Install via Homebrew</h3>
        <pre><code>brew tap 0xa1bed0/mkenv
brew install mkenv</code></pre>
        <h3>Usage</h3>
        <pre><code>cd /path/to/your/project
mkenv .</code></pre>
        <p>mkenv will analyze your project, build a container, and drop you inside. Subsequent runs reuse cached dependencies.</p>
    </section>

    <section id="license">
        <h2>LICENSE</h2>
        <p>mkenv is released under the Elastic License 2.0 (ELv2)</p>
        <div class="license-box">
            <p><strong>You can:</strong> Use mkenv for personal projects, at work, across your company, in CI pipelines, and modify it for internal use.</p>
            <p><strong>You cannot:</strong> Resell mkenv, offer it as a hosted service (SaaS), or build a competing product from it.</p>
            <p>ELv2 keeps mkenv free for developers while preventing commercial exploitation.</p>
        </div>
    </section>

    <section id="outro">
        <h2>BUILT BY DEVELOPERS WHO GOT BURNED</h2>
        <p>We're not a big corporation or Security Enterprise Platform™.</p>
        <p>We're developers who got burned by supply chain attacks and built the tool we wish we had.</p>
        <p>If you've been thinking "I should really isolate my dev environment but it's too much work" — this is for you.</p>
        <p><strong><a href="https://github.com/0xa1bed0/mkenv" target="_blank">Star mkenv on GitHub</a></strong></p>
    </section>
</div>
<footer>
  mkenv &middot; Elastic License 2.0 &middot; Built by <a href="https://albedohq.com" target="_blank">paranoid devs</a><br />
  <p><a href="https://iusevimbtw.com" target="_blank">i use vim btw</a></p>
</footer>
</body>
</html>
