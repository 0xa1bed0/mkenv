<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>mkenv Documentation</title>
<link rel="stylesheet" href="./styles.css?v=4">
<link rel="icon" type="image/svg+xml" href="./favicon.svg?v=7">
</head>
<body>
<header>
    <div class="logo"><a href="index.html"><img src="./logo.svg?v=7" alt="mkenv logo" class="logo-icon">mkenv.sh</a></div>
    <nav>
        <a href="#overview">Overview</a>
        <a href="#installation">Installation</a>
        <a href="#quickstart">Quickstart</a>
        <a href="#mkenv-files">.mkenv Files</a>
        <a href="#llm-support">LLM Support</a>
        <a href="#commands">Commands</a>
        <a href="#configuration">Configuration &amp; Behavior</a>
        <a href="#policies">Policies &amp; Guardrails</a>
        <a href="#faq">FAQ</a>
        <a href="index.html">Back to Landing</a>
    </nav>
</header>
<div class="container">
    <section id="overview">
        <h2>Overview</h2>
        <p>mkenv is a CLI that builds and runs per-project developer containers using Docker with security-focused defaults, disposable sessions, and caching for language tooling. It exists for developers who would rather delete a container than reimage their laptop.</p>
        <p>This documentation covers how to install, run, and configure mkenv. No YAML files required.</p>
    </section>

    <section id="installation">
        <h2>Installation</h2>
        <div class="note">Platform: macOS, Linux, and Windows (via WSL). Bring Docker Desktop or equivalent.</div>
        <h3>Prerequisites</h3>
        <ul>
            <li>macOS 12+ / Linux (arm64 or amd64) / Windows 10+ with WSL2.</li>
            <li>Docker Desktop 4.x or Docker Engine with virtualization enabled.</li>
            <li>Terminal basics (zsh/bash) and permissions to install binaries to <code>$PATH</code>.</li>
        </ul>
        <h3>macOS (Homebrew)</h3>
        <pre><code>brew tap 0xa1bed0/mkenv
brew install mkenv</code></pre>

        <h3>Linux / Windows (WSL)</h3>
        <pre><code># Download the binary (arm64 or amd64)
curl -L https://github.com/0xa1bed0/mkenv/releases/latest/download/mkenv-linux-arm64 -o mkenv
# or for amd64: curl -L https://github.com/0xa1bed0/mkenv/releases/latest/download/mkenv-linux-amd64 -o mkenv

# Make it executable and move to PATH
chmod +x mkenv
sudo mv mkenv /usr/local/bin/</code></pre>

        <h3>Verify Installation</h3>
        <pre><code>mkenv version</code></pre>
        <p><strong>Important:</strong> Ensure Docker is running before launching containers.</p>
    </section>

    <section id="quickstart">
        <h2>Quickstart</h2>
        <ol>
            <li>Navigate to your project directory: <code>cd /path/to/your/project</code></li>
            <li>Run: <code>mkenv .</code></li>
            <li>mkenv analyzes your project, builds a Docker image, and drops you into a container shell</li>
            <li>You're now inside a sandboxed environment with all detected tools installed</li>
        </ol>
        <p><strong>First run:</strong> Builds the full image and caches dependencies (slower)</p>
        <p><strong>Subsequent runs:</strong> Reuse cached layers for fast startup</p>
    </section>

    <section id="mkenv-files">
        <h2>.mkenv Configuration Files</h2>
        <p>While mkenv works with zero configuration, you can customize behavior using <code>.mkenv</code> files. These files provide the same options as command-line flags.</p>

        <h3>Example: Organization-wide Defaults</h3>
        <p>Create <code>~/projects/.mkenv</code> to apply settings to all projects in that directory:</p>
        <pre><code>{
  "enabled_bricks": ["codex", "nvim", "tmux"]
}</code></pre>

        <h3>Example: Project-specific Settings</h3>
        <p>Create <code>.mkenv</code> in your project root:</p>
        <pre><code>{
  "enabled_bricks": ["claude-code"],
  "volumes": ["~/datasets:/data"]
}</code></pre>

        <h3>Example: Install Additional System Packages</h3>
        <p>Create <code>.mkenv</code> in your project root:</p>
        <pre><code>{
  "extra_pkgs": ["git", "curl", "vim", "htop", "jq"]
}</code></pre>
        <p>These packages will be installed via the system's package manager (e.g., apt-get on Debian-based systems).</p>

        <h3>How It Works</h3>
        <ul>
            <li>mkenv walks up from your project directory to the filesystem root</li>
            <li>All <code>.mkenv</code> files found are loaded and merged (root → project)</li>
            <li>Child configs override parent configs</li>
            <li>Command-line flags override all <code>.mkenv</code> files</li>
        </ul>

        <h3>Available Fields</h3>
        <table>
            <thead>
                <tr>
                    <th>Field</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>enabled_bricks</code></td>
                    <td>array</td>
                    <td>Tools to install (e.g., <code>["codex", "claude-code", "nvim", "pulumi"]</code>)</td>
                </tr>
                <tr>
                    <td><code>disabled_bricks</code></td>
                    <td>array</td>
                    <td>Tools to exclude from auto-detection</td>
                </tr>
                <tr>
                    <td><code>extra_pkgs</code></td>
                    <td>array</td>
                    <td>Additional system packages to install (e.g., <code>["git", "curl", "vim"]</code>)</td>
                </tr>
                <tr>
                    <td><code>volumes</code></td>
                    <td>array</td>
                    <td>Additional directories to mount (e.g., <code>["~/data:/data"]</code>)</td>
                </tr>
                <tr>
                    <td><code>disable_auto</code></td>
                    <td>boolean</td>
                    <td>Disable automatic language detection (default: <code>false</code>)</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Use cases:</strong> Set organization-wide defaults, team preferences, or project-specific requirements without repeating command flags.</p>
    </section>

    <section id="llm-support">
        <h2>LLM Support</h2>
        <p>Run AI coding tools safely inside mkenv containers using the <code>--tools</code> flag.</p>

        <h3>Example: Install Claude Code</h3>
        <pre><code>mkenv . --tools claude-code</code></pre>

        <h3>Available LLM Tools</h3>
        <ul>
            <li><code>claude-code</code> — Anthropic's Claude Code CLI</li>
            <li><code>codex</code> — OpenAI's Codex CLI</li>
        </ul>

        <h3>Usage</h3>
        <pre><code># Start container with Claude Code
mkenv . --tools claude-code

# Inside the container, run Claude
claude</code></pre>

        <h3>Security Isolation</h3>
        <p>AI tools run inside the container with restricted access:</p>
        <ul>
            <li>Can only access your project directory</li>
            <li>Cannot access <code>~/.ssh</code>, <code>~/.aws</code>, <code>~/.config</code>, or other credentials</li>
            <li>All AI-generated commands run inside the container, not on your host</li>
            <li>Deleting the container removes all AI-generated changes outside your project folder</li>
        </ul>

        <h3>Combining Tools</h3>
        <p>Install multiple tools at once:</p>
        <pre><code>mkenv . --tools claude-code,nvim,tmux</code></pre>
        <p>Other available tools: <code>nvim</code>, <code>tmux</code>, <code>pulumi</code></p>
    </section>

    <section id="commands">
        <h2>Commands</h2>
        <div class="note">All commands accept <code>-h</code>/<code>--help</code> for usage details.</div>
        <h3><code>mkenv</code> / <code>mkenv run</code></h3>
        <p>Build (if necessary) and run a dev container for the current project.</p>
        <pre><code>mkenv run [PATH] [flags]</code></pre>
        <ul>
            <li>Path defaults to <code>.</code>.</li>
            <li>Analyzes the project, builds image, starts shell with mounts and caches.</li>
        </ul>
        <h2>Flags</h2>
        <table>
            <thead>
                <tr>
                    <th>Flag</th>
                    <th>Type</th>
                    <th>Description</th>
                    <th>Default</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>--tools</code></td>
                    <td>comma list</td>
                    <td>Extra tools to preinstall (e.g. <code>codex,claude,nvim,tmux,pulumi</code>).</td>
                    <td>none</td>
                </tr>
                <tr>
                    <td><code>--langs</code></td>
                    <td>comma list</td>
                    <td>Hint runtimes to prioritize (node,go,python,rust).</td>
                    <td>auto-detect</td>
                </tr>
                <tr>
                    <td><code>--volume</code></td>
                    <td>comma list</td>
                    <td>Mount additional host directories inside the container. Supports relative paths (e.g. "~/foo:~/foo")</td>
                    <td>project dir only</td>
                </tr>
                <tr>
                    <td><code>--rebuild</code></td>
                    <td>bool</td>
                    <td>Ignore cache and rebuild the image from scratch.</td>
                    <td>false</td>
                </tr>
                <tr>
                    <td><code>--shell</code></td>
                    <td>string</td>
                    <td>Preferred shell to launch inside the container (<code>bash</code>, <code>zsh</code>, <code>fish</code>).</td>
                    <td>zsh</td>
                </tr>
                <tr>
                    <td><code>--entrypoint</code></td>
                    <td>string</td>
                    <td>Preferred entrypoint (e.g. "tmux")</td>
                    <td>none</td>
                </tr>
            </tbody>
        </table>
        <h3><code>mkenv attach</code></h3>
        <p>Open an additional shell in an already-running container for the same project.</p>
        <pre><code>mkenv attach [PATH]</code></pre>
        <ul>
            <li>Automatically finds the running container for your project</li>
            <li>Useful for opening multiple terminal windows in the same sandbox</li>
        </ul>
        <h3><code>mkenv list</code></h3>
        <p>List all mkenv containers and their status.</p>
        <pre><code>mkenv list [--verbose]</code></pre>
        <ul>
            <li>Shows project path, container ID, and status</li>
            <li><code>--verbose</code> includes cache and volume details</li>
        </ul>
        <h3><code>mkenv clean</code></h3>
        <p>Remove containers and caches for a project.</p>
        <pre><code>mkenv clean [PATH] [--all]</code></pre>
        <ul>
            <li>Without flags: cleans the current project only</li>
            <li><code>--all</code>: removes all mkenv containers and caches</li>
        </ul>
        <h3><code>mkenv completion</code></h3>
        <p>Generate shell completion scripts.</p>
        <pre><code>mkenv completion [bash|zsh|fish]</code></pre>
        <p>Add the output to your shell config for tab completion.</p>

        <h3><code>mkenv help</code></h3>
        <p>Show help for commands.</p>
        <pre><code>mkenv help [command]</code></pre>
    </section>


    <section id="configuration">
        <h2>Configuration &amp; Behavior</h2>
        <h3>Automatic Language Detection</h3>
        <p>mkenv automatically detects your project's languages and tools by scanning for:</p>
        <ul>
            <li>Node.js: <code>package.json</code>, <code>pnpm-lock.yaml</code>, <code>yarn.lock</code></li>
            <li>Python: <code>requirements.txt</code>, <code>poetry.lock</code>, <code>Pipfile</code></li>
            <li>Go: <code>go.mod</code></li>
            <li>Rust: <code>Cargo.toml</code></li>
            <li>Ruby: <code>Gemfile</code></li>
        </ul>
        <p>Based on what it finds, mkenv installs the appropriate language runtimes, package managers, and language servers.</p>
        <h3>Security Defaults</h3>
        <ul>
            <li>Containers run as a non-root user with restricted permissions</li>
            <li>Only your project directory is mounted (read-write) - no access to your home directory</li>
            <li>Shell history is sanitized to prevent credential leakage</li>
            <li>SSH keys and credentials are not accessible unless you explicitly mount them</li>
        </ul>
        <h3>Caching</h3>
        <p>mkenv caches dependencies using Docker volumes. First run builds everything, subsequent runs are fast. Rebuilds only happen when dependency files change.</p>
        <h3>Security Warnings</h3>
        <p>mkenv scans your project directory for sensitive files (SSH keys, tokens, credential files) before starting. If it detects anything suspicious, it will warn you and ask for confirmation.</p>
        <p><strong>Best practice:</strong> Never mount sensitive credentials into the container. Keep secrets on your host machine only. Remember that the container could be compromised by a supply chain attack.</p>

        <h3>Accessing Your Dev Server</h3>
        <p>Run your dev server normally inside the container:</p>
        <pre><code>npm run dev</code></pre>
        <p>mkenv automatically routes <code>localhost:3000</code> (or any port) from your host machine to the container. Access it from your browser, Postman, or any other tool as usual.</p>
    </section>

    <section id="port-forwarding">
        <h2>How Port Forwarding Works</h2>
        <p>Unlike vanilla Docker or Devcontainers, you can't dynamically expose ports from inside a Docker environment — you need to think of exposed ports in advance. mkenv solves this with a bidirectional reverse proxy.</p>

        <h3>Architecture</h3>
        <pre><code>
┌──────────────────┐
│ Browser          │
│                  │
│ connects to      │
│  localhost:3000  │
└────┬─────────────┘
     │
     │           ┌──────────────────────┐
     │           │  mkenv host process  │    ┌──────────┐
     └────────────►                     │    │ Postgres │
                 │  Binds :3000, :5432  │────► :5432    │
                 │  on Mac on demand    │    └──────────┘
                 └───────────▲──────────┘
                             │
                             │
                     :45454 (fixed port)
           ┌─────────────────┼────────────────────┐
           │    Docker       │                    │
           │                 │                    │
           │    ┌────────────▼──────────────┐     │
           │    │    mkenv Container        │     │
           │    │                           │     │
           │    │  ┌──────────────────────┐ │     │
           │    │  │  Proxy Daemon        │ │     │
           │    │  │  :45454         :5432│ │     │
           │    │  └─────────┬──────────▲─┘ │     │
           │    │            │          │   │     │
           │    │            │          │   │     │
           │    │  ┌─────────▼──────────┼─┐ │     │
           │    │  │  npm run dev :3000 │ │ │     │
           │    │  │                    │ │ │     │
           │    │  │  connects to       │ │ │     │
           │    │  │  localhost:5432 ───┘ │ │     │
           │    │  └──────────────────────┘ │     │
           │    └───────────────────────────┘     │
           │                                      │
           └──────────────────────────────────────┘
</code></pre>

        <p>The mkenv host process acts as a bidirectional traffic hub between your host and the container, using a fixed port (:45454) to avoid Docker's dynamic port limitation.</p>

        <h3>How Traffic Flows</h3>
        <ul>
            <li><strong>Browser → Container:</strong> Your browser accesses localhost:3000 → mkenv host process logs the request and forwards it to the proxy inside the container → Container proxy forwards to your dev server</li>
            <li><strong>Container → Host:</strong> Your containerized app accesses localhost:5432 → if port is bound inside container, connects directly; otherwise routes through container proxy → mkenv host process → host service on that port</li>
        </ul>

        <h3>Key Points</h3>
        <ul>
            <li>Ports are bound <strong>on demand</strong> — no manual configuration needed</li>
            <li>No additional daemons required — the host process starts with <code>mkenv .</code> and dies when you exit</li>
            <li>All connections are logged locally for audit</li>
            <li>Nothing leaves your laptop — all logging happens offline</li>
        </ul>
    </section>

    <section id="policies">
        <h2>Policies &amp; Guardrails</h2>
        <p>mkenv includes a comprehensive policy engine that enforces security guardrails at multiple levels. Policies can be configured globally or per-project using a <code>policy.json</code> file.</p>

        <h3>Security Scanning</h3>
        <p><strong>Secret Detection:</strong></p>
        <ul>
            <li>Scans project files before creating containers</li>
            <li>Warns if secrets, SSH keys, or credentials are detected</li>
            <li>Requires explicit confirmation to proceed if sensitive files are found</li>
        </ul>

        <p><strong>Restricted Directories:</strong></p>
        <ul>
            <li>Automatically blocks dangerous folders like <code>~/.ssh</code>, <code>~/.aws</code>, <code>~/.config</code> from being mounted</li>
            <li>These restrictions cannot be overridden to prevent accidental credential exposure</li>
        </ul>

        <h3>Policy Configuration</h3>
        <p>Create a <code>policy.json</code> file in your mkenv config directory (typically <code>~/.mkenv/policy.json</code>) to enforce organizational policies:</p>

        <pre><code>{
  "disabled_bricks": ["codex"],
  "enabled_bricks": ["nvim", "tmux"],
  "allowed_mount_paths": ["/home/user/projects", "/data"],
  "allowed_project_path": "/home/user/projects",
  "ignore_preferences": false,
  "reverse_proxy": {
    "denied_ports": [5432, 3306],
    "allowed_ports": []
  }
}</code></pre>

        <h3>Policy Fields</h3>
        <table>
            <thead>
                <tr>
                    <th>Field</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>disabled_bricks</code></td>
                    <td>array</td>
                    <td>Block specific tools from being installed (e.g., <code>["codex", "claude-code"]</code>)</td>
                </tr>
                <tr>
                    <td><code>enabled_bricks</code></td>
                    <td>array</td>
                    <td>Force-enable specific tools regardless of project detection</td>
                </tr>
                <tr>
                    <td><code>allowed_mount_paths</code></td>
                    <td>array</td>
                    <td>Whitelist of directories that can be mounted (empty = allow all except blocked)</td>
                </tr>
                <tr>
                    <td><code>allowed_project_path</code></td>
                    <td>string</td>
                    <td>Restrict where mkenv can run (empty = allow all)</td>
                </tr>
                <tr>
                    <td><code>ignore_preferences</code></td>
                    <td>boolean</td>
                    <td>Override user preferences with policy settings</td>
                </tr>
                <tr>
                    <td><code>reverse_proxy</code></td>
                    <td>object</td>
                    <td>Control which host ports containers can access (see Reverse Proxy Security below)</td>
                </tr>
            </tbody>
        </table>

        <h3>Policy File Security</h3>
        <div class="note">
            <strong>Important:</strong> Policy files must have <code>0444</code> permissions (read-only). mkenv will refuse to start if the policy file has incorrect permissions. This prevents unauthorized modification of security policies.
        </div>
        <pre><code>chmod 444 ~/.mkenv/policy.json</code></pre>

        <h3>Reverse Proxy Security</h3>
        <p>mkenv allows containers to access host services (like databases) via a reverse proxy. The policy engine strictly controls which ports can be accessed.</p>

        <h4>Hardcoded Denied Ports (Always Blocked)</h4>
        <p>The following ports are <strong>permanently blocked</strong> and cannot be overridden by policy configuration:</p>
        <ul>
            <li><strong>SSH &amp; Remote Login:</strong> 22, 2222</li>
            <li><strong>Remote Desktop:</strong> 3389 (RDP), 5900-5903 (VNC), 5800 (VNC/HTTP), 3283 (Apple Remote Desktop)</li>
            <li><strong>File Sharing:</strong> 445 (SMB), 139 (NetBIOS), 2049 (NFS), 111 (rpcbind)</li>
            <li><strong>Admin Panels:</strong> 80, 443, 8080, 8443, 9090 (common admin interfaces)</li>
            <li><strong>Container Management:</strong> 2375-2377 (Docker), 6443, 8001, 10250, 10255 (Kubernetes)</li>
            <li><strong>macOS Services:</strong> 548 (AFP), 631 (CUPS), 5353 (mDNS)</li>
            <li><strong>Windows Services:</strong> 135 (RPC), 593 (RPC/HTTP), 1433-1434 (MS SQL), 3268-3269 (LDAP)</li>
        </ul>

        <h4>Custom Port Policies</h4>
        <pre><code>{
  "reverse_proxy": {
    "denied_ports": [5432, 3306],
    "allowed_ports": [8000, 8080]
  }
}</code></pre>
        <ul>
            <li><code>denied_ports</code> - Additional ports to block beyond hardcoded list</li>
            <li><code>allowed_ports</code> - Explicit allowlist (if set, only these ports are accessible, but hardcoded denials still apply)</li>
        </ul>

        <h4>Policy Enforcement</h4>
        <ul>
            <li>All reverse proxy connections are checked against policy</li>
            <li>Denied connections are logged with source information</li>
            <li>All successful proxy connections are logged for auditing</li>
        </ul>

        <h3>Tool Control (Bricks)</h3>
        <p>Policies can control which tools (called "bricks") are available:</p>
        <pre><code>{
  "disabled_bricks": ["claude-code", "codex"],
  "enabled_bricks": ["nvim", "tmux", "pulumi"]
}</code></pre>

        <p><strong>Use Cases:</strong></p>
        <ul>
            <li>Block AI coding tools in security-sensitive environments</li>
            <li>Force-enable required development tools across teams</li>
            <li>Disable automatic detection and use explicit tool lists only</li>
        </ul>

        <h3>Volume Mount Restrictions</h3>
        <pre><code>{
  "allowed_mount_paths": [
    "/home/user/projects",
    "/data/shared"
  ]
}</code></pre>
        <ul>
            <li>If <code>allowed_mount_paths</code> is set, only directories under these paths can be mounted</li>
            <li>Empty list means "allow all" (except hardcoded blocked paths like <code>~/.ssh</code>)</li>
            <li>Relative paths are resolved before checking</li>
            <li>Symlink targets are checked against policy</li>
        </ul>

        <h3>Project Path Restrictions</h3>
        <pre><code>{
  "allowed_project_path": "/home/user/approved-projects"
}</code></pre>
        <ul>
            <li>Restricts where mkenv can be run</li>
            <li>Useful for isolating work projects from personal projects</li>
            <li>Empty string means "allow all"</li>
        </ul>

        <h3>Example: Enterprise Policy</h3>
        <pre><code>{
  "disabled_bricks": ["codex"],
  "enabled_bricks": ["nvim"],
  "allowed_project_path": "/work/projects",
  "allowed_mount_paths": ["/work"],
  "ignore_preferences": true,
  "reverse_proxy": {
    "denied_ports": [5432, 3306, 6379, 27017],
    "allowed_ports": []
  }
}</code></pre>

        <p>This policy:</p>
        <ul>
            <li>Blocks OpenAI Codex but allows Neovim</li>
            <li>Restricts mkenv to <code>/work/projects</code> directory only</li>
            <li>Prevents mounting anything outside <code>/work</code></li>
            <li>Blocks access to common database ports from containers</li>
            <li>Ignores user preferences to enforce organizational standards</li>
        </ul>

        <h3>Example: Developer-Friendly Policy</h3>
        <pre><code>{
  "disabled_bricks": [],
  "enabled_bricks": ["claude-code", "nvim", "tmux"],
  "reverse_proxy": {
    "denied_ports": [],
    "allowed_ports": []
  }
}</code></pre>

        <p>This policy:</p>
        <ul>
            <li>Allows all tools and auto-detection</li>
            <li>Pre-installs commonly used tools (Claude Code, Neovim, Tmux)</li>
            <li>Allows access to all non-hardcoded ports</li>
            <li>Still protects SSH, Docker, and other critical services (hardcoded denials)</li>
        </ul>
    </section>

    <section id="faq">
        <h2>FAQ</h2>
        <h3>Can I use this on Linux or Windows?</h3>
        <p>Yes. Linux is fully supported (arm64 and amd64). Windows works via WSL2 using the Linux binary.</p>
        <h3>Does mkenv replace Docker Desktop?</h3>
        <p>No, it depends on Docker for virtualization. Think of mkenv as the paranoid orchestrator on top.</p>
        <h3>Where is the cache stored?</h3>
        <p>In Docker volumes managed by mkenv. Use <code>mkenv list --verbose</code> to inspect cache details.</p>
        <h3>What happens if the container dies?</h3>
        <p>Run <code>mkenv .</code> again. You'll either reattach or get a fresh container using existing caches.</p>
        <h3>Is this meant for production workloads?</h3>
        <p>No. It's a dev tool for local workstations, not a deployment platform. If you push it to prod, that's on you.</p>
        <h3>Can I keep my editor outside the container?</h3>
        <p>Yes. You can connect VS Code or Cursor to the mkenv container using their remote development features. This keeps the editor UI on your host while running all commands inside the container.</p>
        <h3>Is there telemetry?</h3>
        <p>No analytics pings. If something breaks, file an issue rather than letting logs spy on you.</p>

        <h3>How do I git push?</h3>
        <p>Git operations (push, pull, clone) happen on your host machine where your credentials live. Everything else happens in the sandbox. This separates concerns: work runs isolated with no credentials, git operations run on host with credentials and no bloat.</p>

        <h3>How do I install packages that need sudo?</h3>
        <p>Use <code>mkenv sandbox install &lt;pkg&gt;</code> from inside the container. This is a controlled, audited way to install system packages. You can also specify packages in your <code>.mkenv</code> file with <code>extra_pkgs</code>.</p>

        <h3>What if auto-detection gets my project wrong?</h3>
        <p>Guide it with CLI options (<code>--langs</code>, <code>--tools</code>), a <code>.mkenv</code> file, or adjust ad-hoc with <code>mkenv sandbox install</code>.</p>

        <h3>IDE integration?</h3>
        <p>VS Code and Cursor can connect to mkenv containers using their remote development features. Dedicated plugins coming soon.</p>
    </section>
</div>
<footer>
  mkenv &middot; Elastic License 2.0 &middot; Built by <a href="https://albedohq.com" target="_blank">paranoid devs</a><br />
  <p><a href="https://iusevimbtw.com" target="_blank">i use vim btw</a></p>
</footer>
</body>
</html>
